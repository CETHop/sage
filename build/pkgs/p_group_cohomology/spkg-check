#!/usr/bin/env python

#*****************************************************************************
#
#    Install script
#
#    Copyright (C) 2009 Simon A. King <simon.king@nuigalway.ie>
#
#  Distributed under the terms of the GNU General Public License (GPL),
#  version 2 or later (at your choice)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

import sage
import sage.all
from sage.all import walltime
import inspect
import sys

def members_by_type(M,t):
    L = dir(M)
    if inspect.isclass(M) and len(inspect.getmro(M))>1:
        H = inspect.getmro(M)[1]  # the parent of M in the class hierarchy
        LA = [(getattr(M,X), X) for X in L if not (hasattr(H,X) and hasattr(getattr(H,X),'__doc__') and (getattr(H,X).__doc__ == getattr(M,X).__doc__))]  # only those methods that are not just inherited; inheritance is guessed by the doc strings
    else:
        LA = [(getattr(M,X), X) for X in L]
    return [(X,Y) for X,Y in LA if (repr(type(X))=="<type '%s'>"%t) and is_member_of(X,M)]

def is_member_of(X, M):
    """
    Return True if X is a member/method/... of M

    If M is a class and X is a method that is inherited  from some other
    class, then False is returned.
    """
    if repr(type(M))=="<type 'module'>":
        return (hasattr(X,'__name__') and X.__name__.startswith(M.__name__)) or (hasattr(X,'__module__') and X.__module__==M.__name__)
    if (repr(type(M))=="<type 'classobj'>") or (repr(type(M))=="<type 'instance'>") or (repr(type(M))=="<type 'type'>"):
        return (repr(type(X))=="<type 'instancemethod'>") or (repr(type(X))=="<type 'method_descriptor'>")

def package_tree(M, name=None):
    """
    OUTPUT:

    A list. Item number zero is the object's fully qualified name.
    Number one is its doc string. Number three is the list of its
    children (modules, classes, instances, methods,...), if there
    are any.
    """
    if name is None:
        if hasattr(M,'__name__'):
            name = M.__name__
        else:
            raise ValueError, "please tell me the name of %s"%M


    members = members_by_type(M,'module') + members_by_type(M,'classobj') + members_by_type(M,'type') + members_by_type(M,'instance') + members_by_type(M,'instancemethod') + members_by_type(M,'method_descriptor')
    for i in range(len(members)):
        members[i] = package_tree(members[i][0],name=name+'.'+members[i][1])
    return [name, getattr(M,'__doc__',''), members]

def docstring_list(L, T):
    """
    L is changed in place, no return value. T is a package tree
    """
    L.append((T[0],T[1],len(T[2])))
    for X in T[2]:
        docstring_list(L, X)

def recursive_doctests(M):
    """
    Given a module M, the function recursively tests all examples from M and its members.

    OUTPUT:

    A string (the result of running sage -t on the docstrings) and a
    list of items without doc string.
    """
    from sage.all import tmp_filename
    import os
    from sage.all import SAGE_TMP
    currdir = os.popen('pwd').read().split('\n')[0]
    os.chdir(SAGE_TMP)
    L = package_tree(M)
    D = []
    O = [] # Ergebnis der Doc Tests
    NO = [] # Dinge ohne Doc Test
    docstring_list(D,L)
    for X in D:
        if (X[1] is None or (not "sage: " in X[1])):
            if X[2]==0:
                #print "Warning: No doc test in", X[0]
                NO.append(X[0])
        else:
            print X[0], '...',
            sys.stdout.flush()
            F = file('RecDoctest.py','w')
            F.write('"""\n%s\n"""\n'%(X[1]))
            F.close()
            Res = os.popen('sage -t -optional -long RecDoctest.py').read()
            if Res.split('\n')[-3]!='All tests passed!':
                O.append((X[0],Res))
                print '\b\b\b\b--> Error'
            else:
                print '\b\b\b\b--> OK'
    os.chdir(currdir)
    return O,NO

if __name__ == '__main__':
    import pGroupCohomology
    wt = walltime()
    print "Testing the components of the package pGroupCohomology..."
    O,NO = recursive_doctests(pGroupCohomology)
    if O or NO:
        RES = open('test.log','w')
    else:
        RES = None
    if O:
        print "Some doc tests resulted in errors."
        RES.write("The following doc tests had errors:\n")
        for X in O:
            RES.write(X[0])
            RES.write(' resulted in\n')
            RES.write(X[1])
            RES.write("\n-------------------------------------------------------------\n")
    else:
        print "All doc tests passed!\n-------------------------------------------------------------\n"
        if RES is not None:
            RES.write("All doc tests passed!\n-------------------------------------------------------------\n")

    if NO:
        print "Some items have no doc tests."
        RES.write("Warning: The following items had no doc tests\n")
        for X in NO:
            RES.write('  '+X+'\n')

    if RES is not None:
        RES.close()
        print "Please see the file 'test.log' in the current directory"
    print "Total time: %.2f minutes\n"%(walltime(wt)/60)


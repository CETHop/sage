=== modified file 'CHANGES'
--- CHANGES	2011-02-01 19:05:42 +0000
+++ CHANGES	2011-06-16 11:11:16 +0000
@@ -1,3 +1,14 @@
+- Fix for first_of when non-empty child is followed by a child that has a
+  missing field.
+
+- Fix for crossref lookups when key is not lower case.
+
+- Completed unsrt python style: it now contains all entry types.
+
+- Added doctree backend for rendering into a tree of docutils nodes.
+
+- Added support for non-string backends.
+
 Version 0.15
 ------------
 (released on February 1, 2011)

=== modified file 'pybtex/backends/__init__.py'
--- pybtex/backends/__init__.py	2011-03-03 14:15:55 +0000
+++ pybtex/backends/__init__.py	2011-06-16 11:11:16 +0000
@@ -23,7 +23,7 @@
 from pybtex.plugin import Plugin


-available_plugins = ('latex', 'html', 'plaintext')
+available_plugins = ('latex', 'html', 'plaintext', 'doctree')


 class BaseBackend(Plugin):
@@ -48,6 +48,10 @@

         raise NotImplementedError

+    def render_sequence(self, text):
+        """Render a sequence of rendered text objects."""
+        return "".join(text)
+
     def write_entry(self, label, key, text):
         raise NotImplementedError


=== added file 'pybtex/backends/doctree.py'
--- pybtex/backends/doctree.py	1970-01-01 00:00:00 +0000
+++ pybtex/backends/doctree.py	2011-06-16 11:11:16 +0000
@@ -0,0 +1,56 @@
+"""Doctree backend for pybtex."""
+
+import docutils.nodes
+
+from pybtex.backends import BaseBackend
+import pybtex.richtext
+
+class Backend(BaseBackend):
+    name = 'doctree'
+
+    symbols = {
+        'ndash': docutils.nodes.inline(u'\u2013', u'\u2013'),
+        'newblock': docutils.nodes.inline(u' ', u' '),
+        'nbsp': docutils.nodes.inline(u'\u00a0', u'\u00a0')
+    }
+    tags = {
+         'emph': docutils.nodes.emphasis,
+    }
+
+    def format_text(self, text):
+        return docutils.nodes.inline(text, text)
+
+    def format_tag(self, tag_name, text):
+        tag = self.tags[tag_name]
+        if isinstance(text, basestring):
+            return tag(text, text)
+        else:
+            # must be a docutils node
+            node = tag('', '')
+            node.children.append(text)
+            return node
+
+    def write_entry(self, key, label, text):
+        # This is a very simple implementation, does not include key
+        # and label yet.
+        node = docutils.nodes.paragraph()
+        node.children.append(text)
+        return node
+
+    def render_sequence(self, text):
+        """Return backend-dependent representation of sequence *text*
+        of rendered Text objects.
+        """
+        if len(text) != 1:
+            node = docutils.nodes.inline('', '')
+            node.children.extend(text)
+            return node
+        else:
+            return text[0]
+
+    def write_to_doctree(self, formatted_entries, doctree):
+        """Append all entries to *doctree*."""
+        for entry in formatted_entries:
+            doctree.append(
+                self.write_entry(
+                    entry.key, entry.label, entry.text.render(self)))

=== modified file 'pybtex/database/__init__.py'
--- pybtex/database/__init__.py	2011-04-16 08:49:09 +0000
+++ pybtex/database/__init__.py	2011-06-16 11:11:16 +0000
@@ -210,7 +210,8 @@
         )

     def get_crossref(self):
-        return self.collection.entries[self.fields['crossref']]
+        # TODO should convert crossref to lower case during parsing?
+        return self.collection.entries[self.fields['crossref'].lower()]

     def add_person(self, person, role):
         self.persons.setdefault(role, []).append(person)

=== modified file 'pybtex/richtext.py'
--- pybtex/richtext.py	2011-01-06 18:14:02 +0000
+++ pybtex/richtext.py	2011-06-16 11:11:16 +0000
@@ -125,7 +125,7 @@
                 text.append(backend.format_text(item))
             else:
                 text.append(item.render(backend))
-        return "".join(text)
+        return backend.render_sequence(text)

     def enumerate(self):
         for n, child in enumerate(self):

=== modified file 'pybtex/style/formatting/unsrt.py'
--- pybtex/style/formatting/unsrt.py	2011-01-19 15:54:00 +0000
+++ pybtex/style/formatting/unsrt.py	2011-06-16 11:11:16 +0000
@@ -39,55 +39,86 @@
 class Style(BaseStyle):
     name = 'unsrt'

-    def format_names(self, role):
-        return sentence(capfirst=False) [names(role, sep=', ', sep2 = ' and ', last_sep=', and ')]
+    def format_names(self, role, as_sentence=True):
+        formatted_names = names(role, sep=', ', sep2 = ' and ', last_sep=', and ')
+        if as_sentence:
+            return sentence(capfirst=False) [formatted_names]
+        else:
+            return formatted_names

     def format_article(self, e):
         volume_and_pages = first_of [
-            join [field('volume'), optional [':', pages]],
-            words ['pages', optional [pages]]
+            # volume and pages, with optional issue number
+            optional [
+                join [
+                    field('volume'),
+                    optional['(', field('number'),')'],
+                    ':', pages
+                ],
+            ],
+            # pages only
+            words ['pages', pages],
         ]
         template = toplevel [
             self.format_names('author'),
-            sentence(capfirst=False) [field('title')],
+            self.format_title(e, 'title'),
             sentence(capfirst=False) [
-                tag('emph') [field('journal')], volume_and_pages, date],
+                tag('emph') [field('journal')],
+                optional[ volume_and_pages ],
+                date],
+            sentence(capfirst=False) [ optional_field('note') ],
         ]
         return template.format_data(e)
-
+
     def format_author_or_editor(self, e):
-        if e.persons['author']:
-            return self.format_names('author')
-        else:
-            editors = self.format_names('editors')
-            if len(e.persons['editors']) > 1:
-                word = 'editors'
-            else:
-                word = 'editor'
-            return words [editors, word]
+        return first_of [
+            optional[ self.format_names('author') ],
+            self.format_editor(e),
+        ]
+
+    def format_editor(self, e, as_sentence=True):
+        editors = self.format_names('editor', as_sentence=False)
+        if 'editor' not in e.persons:
+            # when parsing the template, a FieldIsMissing exception
+            # will be thrown anyway; no need to do anything now,
+            # just return the template that will throw the exception
+            return editors
+        if len(e.persons['editor']) > 1:
+            word = 'editors'
+        else:
+            word = 'editor'
+        result = join(sep=', ') [editors, word]
+        if as_sentence:
+            return sentence(capfirst=False) [result]
+        else:
+            return result

-    def format_volume_and_series(self, e):
+    def format_volume_and_series(self, e, as_sentence=True):
         volume_and_series = optional [
-            sentence(capfirst=False, sep=' ') [
-                'Volume', field('volume'), optional [
+            words [
+                'volume', field('volume'), optional [
                     words ['of', field('series')]
                 ]
             ]
         ]
         number_and_series = optional [
-            sentence(capfirst=False, sep=' ') [
-                join(sep=Symbol('nbsp')) ['Number', field('number')],
+            words [
+                join(sep=Symbol('nbsp')) ['number', field('number')],
                 optional [
                     words ['in', field('series')]
                 ]
             ]
         ]
-        series = optional [ sentence(capfirst=False) [field('series')] ]
-        return first_of [
+        series = optional_field('series')
+        result = first_of [
                 volume_and_series,
                 number_and_series,
                 series,
             ]
+        if as_sentence:
+            return sentence(capfirst=False) [result]
+        else:
+            return result

     def format_chapter_and_pages(self, e):
         return join(sep=', ') [
@@ -95,19 +126,99 @@
             optional [words ['pages', pages]],
         ]

+    def format_edition(self, e):
+        return optional [
+            words [
+                field('edition', apply_func=lambda x: x.lower()),
+                'edition',
+            ]
+        ]
+
+    def format_title(self, e, which_field, as_sentence=True):
+
+        def protected_capitalize(x):
+            """Capitalize string, but protect {...} parts."""
+            result = ""
+            level = 0
+            for pos, c in enumerate(x):
+                if c == '{':
+                    level += 1
+                elif c == '}':
+                    level -= 1
+                elif pos == 0:
+                    c = c.upper()
+                elif level <= 0:
+                    c = c.lower()
+                result += c
+            return result
+
+        formatted_title = field(
+            which_field, apply_func=protected_capitalize)
+        if as_sentence:
+            return sentence(capfirst=False) [ formatted_title ]
+        else:
+            return formatted_title
+
+    def format_btitle(self, e, which_field, as_sentence=True):
+        formatted_title = tag('emph') [ field(which_field) ]
+        if as_sentence:
+            return sentence[ formatted_title ]
+        else:
+            return formatted_title
+
+    def format_address_organization_publisher_date(
+        self, e, include_organization=True):
+        """Format address, organization, publisher, and date.
+        Everything is optional, except the date.
+        """
+        # small difference from unsrt.bst here: unsrt.bst
+        # starts a new sentence only if the address is missing;
+        # for simplicity here we always start a new sentence
+        if include_organization:
+            organization = optional_field('organization')
+        else:
+            organization = None
+        return first_of[
+            # this will be rendered if there is an address
+            optional [
+                join(sep=' ') [
+                    sentence[
+                        field('address'),
+                        date,
+                    ],
+                    sentence[
+                        organization,
+                        optional_field('publisher'),
+                    ],
+                ],
+            ],
+            # if there is no address then we have this
+            sentence[
+                organization,
+                optional_field('publisher'),
+                date,
+            ],
+        ]
+
     def format_book(self, e):
         template = toplevel [
             self.format_author_or_editor(e),
-            tag('emph') [sentence [field('title')]],
+            self.format_btitle(e, 'title'),
             self.format_volume_and_series(e),
-            sentence [field('publisher'), date],
+            sentence [
+                field('publisher'),
+                optional_field('address'),
+                self.format_edition(e),
+                date
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
         ]
         return template.format_data(e)

     def format_booklet(self, e):
         template = toplevel [
-            sentence [self.format_names('author')],
-            sentence [field('title')],
+            self.format_names('author'),
+            self.format_title(e, 'title'),
             sentence [
                 optional_field('howpublished'),
                 optional_field('address'),
@@ -121,7 +232,7 @@
         template = toplevel [
             sentence [self.format_names('author')],
             sentence [
-                tag('emph') [field('title')],
+                self.format_btitle(e, 'title'),
                 self.format_chapter_and_pages(e),
             ],
             self.format_volume_and_series(e),
@@ -136,3 +247,157 @@
             ]
         ]
         return template.format_data(e)
+
+    def format_incollection(self, e):
+        template = toplevel [
+            sentence [self.format_names('author')],
+            self.format_title(e, 'title'),
+            words [
+                'In',
+                sentence(capfirst=False) [
+                    optional[ self.format_editor(e, as_sentence=False) ],
+                    self.format_btitle(e, 'booktitle', as_sentence=False),
+                    self.format_volume_and_series(e, as_sentence=False),
+                    self.format_chapter_and_pages(e),
+                ],
+            ],
+            sentence [
+                optional_field('publisher'),
+                optional_field('address'),
+                self.format_edition(e),
+                date,
+            ],
+        ]
+        return template.format_data(e)
+
+    def format_inproceedings(self, e):
+        template = toplevel [
+            sentence [self.format_names('author')],
+            self.format_title(e, 'title'),
+            words [
+                'In',
+                sentence(capfirst=False) [
+                    optional[ self.format_editor(e, as_sentence=False) ],
+                    self.format_btitle(e, 'booktitle', as_sentence=False),
+                    self.format_volume_and_series(e, as_sentence=False),
+                    optional[ pages ],
+                ],
+                self.format_address_organization_publisher_date(e),
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
+        ]
+        return template.format_data(e)
+
+    def format_manual(self, e):
+        # TODO this only corresponds to the bst style if author is non-empty
+        # for empty author we should put the organization first
+        template = toplevel [
+            optional [ sentence [ self.format_names('author') ] ],
+            self.format_btitle(e, 'title'),
+            sentence [
+                optional_field('organization'),
+                optional_field('address'),
+                self.format_edition(e),
+                optional[ date ],
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
+        ]
+        return template.format_data(e)
+
+    def format_mastersthesis(self, e):
+        template = toplevel [
+            sentence [self.format_names('author')],
+            self.format_title(e, 'title'),
+            sentence[
+                "Master's thesis",
+                field('school'),
+                optional_field('address'),
+                date,
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
+        ]
+        return template.format_data(e)
+
+    def format_misc(self, e):
+        template = toplevel [
+            optional[ sentence [self.format_names('author')] ],
+            optional[ self.format_title(e, 'title') ],
+            sentence[
+                optional[ field('howpublished') ],
+                optional[ date ],
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
+        ]
+        return template.format_data(e)
+
+    def format_phdthesis(self, e):
+        template = toplevel [
+            sentence [self.format_names('author')],
+            self.format_btitle(e, 'title'),
+            sentence[
+                'PhD thesis',
+                field('school'),
+                optional_field('address'),
+                date,
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
+        ]
+        return template.format_data(e)
+
+    def format_proceedings(self, e):
+        template = toplevel [
+            first_of [
+                # there are editors
+                optional [
+                    join(' ')[
+                        self.format_editor(e),
+                        sentence [
+                            self.format_btitle(e, 'title', as_sentence=False),
+                            self.format_volume_and_series(e, as_sentence=False),
+                            self.format_address_organization_publisher_date(e),
+                        ],
+                    ],
+                ],
+                # there is no editor
+                optional_field('organization'),
+                sentence [
+                    self.format_btitle(e, 'title', as_sentence=False),
+                    self.format_volume_and_series(e, as_sentence=False),
+                    self.format_address_organization_publisher_date(
+                        e, include_organization=False),
+                ],
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
+        ]
+        return template.format_data(e)
+
+    def format_techreport(self, e):
+        template = toplevel [
+            sentence [self.format_names('author')],
+            self.format_title(e, 'title'),
+            sentence [
+                words[
+                    first_of [
+                        optional_field('type'),
+                        'Technical Report',
+                    ],
+                    optional_field('number'),
+                ],
+                field('institution'),
+                optional_field('address'),
+                date,
+            ],
+            sentence(capfirst=False) [ optional_field('note') ],
+        ]
+        return template.format_data(e)
+
+    def format_unpublished(self, e):
+        template = toplevel [
+            sentence [self.format_names('author')],
+            self.format_title(e, 'title'),
+            sentence(capfirst=False) [
+                field('note'),
+                optional[ date ]
+            ],
+        ]
+        return template.format_data(e)

=== modified file 'pybtex/style/template.py'
--- pybtex/style/template.py	2011-03-03 14:27:21 +0000
+++ pybtex/style/template.py	2011-06-16 11:11:16 +0000
@@ -149,7 +149,7 @@
         return f(data)

 def _format_list(list_, data):
-    return [_format_data(part, data) for part in list_]
+    return (_format_data(part, data) for part in list_)

 def node(f):
     if f.__doc__:
@@ -232,9 +232,10 @@
     return text

 class FieldIsMissing(PybtexError):
-    def __init__(self, field_name):
+    def __init__(self, field_name, entry):
         self.field_name = field_name
-        super(FieldIsMissing, self).__init__('missing field: %s' % field_name)
+        super(FieldIsMissing, self).__init__(
+            'missing field: %s in %s' % (field_name, entry))

 @node
 def field(children, data, name, apply_func=None):
@@ -244,7 +245,7 @@
     try:
         field = data.fields[name]
     except KeyError:
-        raise FieldIsMissing(name)
+        raise FieldIsMissing(name, data)
     else:
         if apply_func:
             field = apply_func(field)
@@ -255,7 +256,12 @@
     """Return formatted names."""

     assert not children
-    persons = data.persons[role]
+    try:
+        persons = data.persons[role]
+    except KeyError:
+        # role is a bibtex field so it makes sense
+        # to raise FieldIsMissing; optional will catch it
+        raise FieldIsMissing(role, data)
     return join(**kwargs) [[person.text for person in persons]].format_data(data)

 @node

